# 数据库

## 数据库模块![](E:\PDF\知识库\数据库\img\数据库八大模块.png)
##  数据库最主要的功能是 存储模块
>* 存储方式 机械硬盘 固态硬盘 或者是 磁盘阵列中（磁盘阵列是由很多块独立的磁盘，组合成一个容量巨大的磁盘组）

> * 提高执行效率要尽可能的较少IO
> * 一次IO 读取单行数据和多行数据相差不大
## 索引模块![](https://github.com/lh1228216717/knowledgeBase/blob/master/%E6%95%B0%E6%8D%AE%E5%BA%93/img/%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F.png?raw=true)
>* 数据库存储的最小单位是块或者页
##  sql 
>* sql 又称为 结构化英文查询语言简称为SEQUEL
>使用编程语时，所写的语句被称为嵌入式SQL语句并且在应用程序编译之前会由SQL预处理器进行预处理
>Oracle基于查询成本的优化器（CBO）用来产生实际的执行计划
>优化器（CBO）决定如何访问表，按照什么样的顺序来处理他们，以及如何将多个表连结起来及如何使用筛选器
## select 执行顺序
![oracle执行顺序](E:\PDF\知识库\数据库\img\执行顺序.png)
>* 首先处理的并不是写在第一行的语句（Select语句）而是FROM字句
>from子句可以包含表、视图、物化视图、分区或自分区或者可以建立一个子查询来来生成子对象
>where子句提供了一种方法，可以按照条件来限制查询最终返回的结果集的行数
>group by 子句将执行FROM和WHERE 子句后得到的结果进行整合查询出来的结果按照group by 子句中列出来的条件进行分组，来为为一个分组得出一行汇总结果，可以按照FROM子句中所列出来的对象的任意字段进行分组 
>Select列表中的任何非聚合字段都必须包含在group by 子句中
>HAVING 本质上是在group by 子句执行后用来筛选汇总的第二个where子句
>select列表列出查询的返回最终结果集中需要显示哪些列 可以是一个实际的列 一个表达式 或者是 select子查询
>order by 子句用来对查询最终的返回结果进行排序
>较小的排序在内存中实现，较大的排序将使用临时磁盘空间来完成 排序是查询过程中开销相对大的一个处理步骤
>## INSERT语句
>* insert语句用来像表、分区或视图中添加行
>单表插入将会向一个表中插入一行数据 可以显示的列出插入值也可以通过一个子查询来获取
>多表插入将会向一个或多个表中插入行
>子查询插入 子查询返回的每一行数据都会用来生成需要插入的新行的列值
```sql
inser into table(...)
select ... from table
-- 如果非插入列有非空约束那么可能会返回一个约束错误 语句执行也会失败
## merge

## 注意
>* 聚合函数可以当作having的条件也可以用作order by 子句但是不能用于 where子句 
>SQL 中逻辑比较的可能结果时TRUE或者FALSE以及未知，当其中包含控制（null）的时候比较的结果就会时未知，空值与任何值作比较或者用在表达式中都会得到空值，或者是未知一个空值代表一个响应值的缺失并且可能因为SQL语言中的不同部分对空值的处理不同而令人费解
>进行筛选的比较条件包含空值的时候将作为false来对待
```sql
--直接创建一个 指定查询出来额表
create table a  as select * from table
```
